//
// MapReduceFunc.go
//
// This file contains the definitions for the 'mapFunc' and 'reduceFunc' functions used by
// 'map' and 'reduce' workers (see DoReduce.go and DoMap.go).
//
// The MIT License (MIT)
//
// Copyright (c) 2023 Luke Andrews.  All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of this
// software and associated documentation files (the "Software"), to deal in the Software
// without restriction, including without limitation the rights to use, copy, modify, merge,
// publish, distribute, sub-license, and/or sell copies of the Software, and to permit persons
// to whom the Software is furnished to do so, subject to the following conditions:
//
// * The above copyright notice and this permission notice shall be included in all copies or
// substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
// PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR 
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//
import (
	"fmt"
	"os"
	"regexp"
	"strconv"
	"strings"
)

//
// mapFunc
//
// This mapping function is called once for each piece of the input.
// In this framework, the key is the name of the file that is being processed,
// and the value is the file's contents.
//
//		fileName - the name of the input file
//      content  - the content of the input file
//
// Returns a slice of key/value pairs, each represented by a mapreduce.KeyValue.
//
func mapFunc(fileName string, content string) (res []mapreduce.KeyValue) {
	//
	// Create array of all content words as strings:
	//
	var re *regexp.Regexp = regexp.MustCompile("[^a-zA-Z\\s]+")

	//content = strings.ToLower(content)   <-- uncomment if words are case incensitive
	content = re.ReplaceAllString(content, " ")

	var contentWords []string = strings.Fields(content)

	//
	// Construct the word count KeyValue array:
	//
	res = ConstructWordCounts(contentWords)

	return
}

//
// reduceFunc
//
// This reduce function is called once for each key generated by Map, with a
// list of that key's string value (merged across all inputs).
//
//		key    - the key generated by Map
//		values - the list of string values of key
//
// Returns a new single output value for the input key.
//
func reduceFunc(key string, values []string) string {
	var outValue string = ""
	var intValue int    = 0
	var err      error  = nil	

	for _, v := range values {
		tempValue, tempErr := strconv.Atoi(v)

		if tempErr != nil {
			err = tempErr
			break
		}

		intValue += tempValue
	}

	if err != nil {
		// Do not log. Propogate error to caller via output value.
		outValue = "error"
	} else {
		outValue = strconv.Itoa(intValue)
	}

	return outValue
}

//
// ConstructWordCounts
//
// Constructs the array of KeyValue structs for word counts.
//
// 		contentWords  - the string array of words as read and modified from the file.
//
// Returns the array of KeyValue structs.
//
func ConstructWordCounts(contentWords []string) []mapreduce.KeyValue {
	wordCounts   := make([]mapreduce.KeyValue, 0)
	visitedWords := make([]string, 0)

	for i, word := range contentWords {
		if !Contains(visitedWords, word) {
			var count int = 1

			for j := i + 1; j < len(contentWords); j++ {
				if contentWords[j] == word {
					count++
				}
			}

			wordCounts   = append(wordCounts, mapreduce.KeyValue{word, strconv.Itoa(count)})
			visitedWords = append(visitedWords, word)
		}
	}

	return wordCounts
}

//
// Contains
//
// Determines if a given array contains a given value.
//
//		array - the array to iterate for value
//      value - the value to check if contained 
//
// Returns true if the value is contained. Otherwise, false.
//
func Contains(array []string, value string) bool {
	for _, s := range array {
		if s == value {
			return true
		}
	}

	return false
}
